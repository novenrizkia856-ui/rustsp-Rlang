RustS+ ke depan harus diperlakukan bukan sebagai “bahasa dengan sintaks baru”, tetapi sebagai sistem formal untuk menjamin kebenaran makna program. Arsitektur pengembangannya berangkat dari gagasan bahwa Rust sudah menyelesaikan masalah memory correctness, sementara RustS+ menyelesaikan masalah yang lebih tinggi: correctness of intent, state, dan efek terhadap dunia nyata. Karena itu, seluruh toolchain RustS+ harus berorientasi pada analisis semantik, bukan sekadar transformasi teks. Pipeline resmi RustS+ dibangun di atas rangkaian IR formal: dari .rss ke AST (struktur), lalu ke HIR (makna dan scope), lalu ke EIR (kontrak efek), dan baru kemudian diturunkan ke Rust. Dengan arsitektur ini, RustS+ tidak lagi menjadi “regex compiler”, melainkan semantic compiler yang memahami apa yang dilakukan program secara formal.

Di pusat sistem ini terdapat Type System dua-lapis: lapisan pertama adalah Rust type system (i32, struct, enum, borrow, generics), dan lapisan kedua adalah Effect Capability System. Setiap nilai tidak hanya memiliki tipe data, tetapi juga hak atas realitas: apakah ia boleh dibaca (read x), ditulis (write x), melakukan I/O, alokasi memori, atau panic. Capability write(x) diperlakukan sebagai linear resource seperti &mut T di Rust: ia tidak boleh diduplikasi dan hanya boleh dimiliki satu pihak pada satu waktu. Ini membuat perubahan state dunia menjadi sesuatu yang eksklusif, eksplisit, dan dapat diverifikasi, sama seperti perubahan memori di Rust.

Setiap fungsi di RustS+ secara formal bertipe
(parameter types) → return type + capability set.
Jika sebuah fungsi mendeklarasikan effects(write acc, io), maka secara tipe ia memegang dua token: satu token eksklusif untuk mengubah acc, dan satu token global untuk I/O. Ketika fungsi memanggil fungsi lain, capability ini harus dipropagasi secara tipe. Jika fungsi pure mencoba memanggil fungsi effectful, atau jika ia gagal mempropagasi efek dari callee, itu menjadi type error (RSPL301 / RSPL302), bukan sekadar warning. Dengan model ini, “kode tidak jujur” tidak mungkin lolos karena ia melanggar kontrak tipe.

HIR dan EIR bersama-sama membentuk sistem pengecekan yang setara dengan borrow checker, tetapi untuk makna program. HIR memastikan scope, mutabilitas, dan niat (mut vs outer vs shadowing) konsisten dan tidak ambigu. EIR membangun Effect Graph yang melacak dari mana efek berasal, ke mana ia mengalir, dan siapa yang memiliki hak untuk melakukan perubahan. Dari graph ini, compiler dapat mendeteksi konflik seperti dua fungsi yang sama-sama menulis w tanpa koordinasi, kebocoran efek ke closure, atau efek yang dilakukan di luar scope yang sah — semuanya sebelum satu baris Rust pun dihasilkan.

Agar sistem ini bekerja, RustS+ menggunakan Effect Inference Algorithm yang berjalan di atas HIR. Setiap ekspresi dan statement menghasilkan jejak efek yang dihitung secara struktural, bukan berbasis teks. Misalnya, literal tidak menghasilkan efek, membaca variabel menghasilkan read(x), mengakses w.x juga menghasilkan read(w), sementara assignment ke field seperti w.x = 3 menghasilkan write(w). Ini karena mutasi terhadap field dianggap sebagai mutasi terhadap owner objek. Rebinding seperti w = new_w tidak menghasilkan write(w) karena itu hanya mengganti binding, bukan memodifikasi isi. Pemanggilan fungsi menghasilkan gabungan efek dari argumen dan capability yang dideklarasikan oleh fungsi tersebut. Pola seperti println!, Vec::new, atau unwrap dipetakan ke io, alloc, dan panic secara AST-level. Untuk control flow (if, match, while), efek dari seluruh cabang digabungkan. Dengan cara ini, compiler dapat menghitung DetectedEffects untuk setiap fungsi dan memverifikasinya terhadap DeclaredEffects (RSPL300), memaksa propagasi efek antar fungsi (RSPL301), melarang fungsi pure memanggil fungsi effectful (RSPL302), serta mendeteksi konflik kepemilikan write(x) di sepanjang jalur eksekusi (RSPL315).

Dengan fondasi ini, RustS+ siap masuk ke dunia produksi dengan cara yang sama seperti Rust dulu: lewat dogfooding di sistem kritikal seperti DSDN. DSDN akan memaksa RustS+ menghadapi realitas concurrency, ledger state, transaction ordering, determinisme, dan keamanan. Karena RustS+ memformalkan “siapa yang boleh mengubah apa dan kapan”, ia sangat cocok menjadi bahasa inti untuk financial engines, blockchain state machines, dan distributed AI pipelines — yaitu domain di mana bug bukan sekadar crash, tetapi kegagalan kepercayaan.

Intinya, RustS+ berkembang bukan dengan menambah fitur, tetapi dengan memperdalam makna yang bisa diverifikasi compiler. Dengan IR formal, type system berbasis capability, dan effect ownership yang linear, RustS+ menjadi bahasa yang bukan hanya aman secara memori, tetapi aman secara realitas. Setelah fondasi ini kuat, barulah ia bisa meluas seperti Rust: dari DSDN ke seluruh dunia sistem yang tidak boleh salah.