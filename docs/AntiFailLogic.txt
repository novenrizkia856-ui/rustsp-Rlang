Dalam RustS+, pencegahan bug logika diperlakukan sebagai masalah fundamental yang setara pentingnya dengan pencegahan bug memori di Rust. Jika Rust membangun sistem kepemilikan, peminjaman, dan lifetime untuk memastikan bahwa memori tidak pernah diakses tanpa hak yang sah, maka RustS+ memperluas prinsip tersebut ke ranah makna program itu sendiri. Bug logika dipahami bukan sebagai kesalahan sintaks atau tipe, melainkan sebagai perubahan keadaan dan efek yang terjadi tanpa kesadaran atau niat eksplisit dari pengembang. Oleh karena itu, RustS+ dirancang untuk memastikan bahwa setiap perubahan makna program harus dinyatakan secara sadar, terlihat jelas di kode, dan diverifikasi sebelum program diterjemahkan ke Rust murni.

Konsep kunci yang digunakan RustS+ untuk mencapai tujuan ini adalah kepemilikan efek (effect ownership). Dalam model ini, perubahan terhadap state, baik berupa mutasi data, interaksi dengan dunia luar, maupun perubahan urutan eksekusi yang bermakna, diperlakukan sebagai sesuatu yang “dimiliki” oleh bagian kode tertentu. Sebuah fungsi secara default dianggap tidak memiliki efek apa pun; ia murni melakukan komputasi dan menghasilkan nilai. Ketika sebuah fungsi ingin mengubah state atau menimbulkan efek, hal tersebut harus dideklarasikan secara eksplisit. Dengan cara ini, RustS+ mencegah terjadinya efek samping tersembunyi yang sering menjadi sumber bug logika yang sulit dilacak.

Pendekatan ini menciptakan analogi langsung dengan sistem kepemilikan Rust. Seperti halnya Rust melarang dua pemilik mutable atas data yang sama, RustS+ melarang dua sumber efek yang tidak terkoordinasi terhadap state yang sama. Efek memiliki ruang lingkup, masa berlaku, dan batasan penggunaan yang jelas, sehingga perubahan logika program tidak dapat “bocor” ke bagian lain tanpa izin yang eksplisit. Akibatnya, alur logika program menjadi lebih mudah dipahami secara lokal, karena pengembang tidak perlu mengasumsikan adanya perubahan tersembunyi di luar konteks yang terlihat.

RustS+ juga memanfaatkan pemisahan tahap kompilasi untuk memperkuat jaminan ini. Tahap pertama kompilasi berfokus pada analisis logika, di mana deklarasi efek, kepemilikan state, dan aturan perubahan diperiksa secara ketat. Pada tahap ini, ketidakkonsistenan logika, penggunaan efek tanpa deklarasi, atau pelanggaran terhadap kontrak logika ditangani sebagai kesalahan kompilasi, bukan sebagai bug runtime. Setelah logika program dinyatakan konsisten dan eksplisit, barulah kode tersebut diturunkan ke Rust murni dan diperiksa kembali oleh sistem kepemilikan memori Rust. Dengan pemisahan ini, RustS+ menciptakan dua lapisan keamanan: satu untuk makna program, dan satu untuk memori fisik.

Yang membuat pendekatan ini tetap sederhana dan tidak membebani pengembang adalah prinsip “default aman”. Dalam RustS+, fungsi tanpa deklarasi efek dianggap murni dan bebas efek, sehingga sebagian besar kode sehari-hari tetap ringkas dan mudah dibaca. Deklarasi efek hanya muncul ketika benar-benar dibutuhkan, mirip dengan bagaimana kata kunci mut digunakan di Rust. Dengan demikian, RustS+ tidak menghilangkan fleksibilitas, tetapi memaksa kejujuran dalam kode: setiap perubahan penting terhadap state atau alur logika harus diakui dan dituliskan secara eksplisit.

Dengan fondasi ini, RustS+ memposisikan dirinya bukan sekadar sebagai bahasa yang aman dari segi memori, tetapi sebagai bahasa yang menjaga integritas makna program. Ia mencegah kelas bug yang selama ini dianggap “tak terhindarkan” dalam pengembangan sistem kompleks, yaitu bug logika yang muncul dari asumsi yang keliru dan efek samping tersembunyi. Melalui kepemilikan efek, deklarasi eksplisit, dan analisis logika sebelum kompilasi Rust, RustS+ menawarkan pendekatan baru: bahasa sistem yang tidak hanya aman untuk mesin, tetapi juga jujur terhadap niat pengembang.