Konsep Struct dalam RustS+
Dalam RustS+, struct merepresentasikan data terstruktur dengan layout memori yang jelas, deterministik, dan eksplisit, sebagaimana tuntutan bahasa sistem. RustS+ tidak mencoba mengabstraksi atau menyembunyikan bagaimana data disimpan di memori, melainkan hanya menyederhanakan cara manusia menuliskannya. Oleh karena itu, definisi struct di RustS+ menghilangkan simbol-simbol yang bersifat kebisingan sintaks seperti titik dua dan koma, tanpa mengubah makna atau kekuatan semantik yang dimiliki Rust. Urutan field dalam struct RustS+ memiliki arti penting karena secara langsung menentukan layout memori, sehingga bahasa ini tetap cocok untuk kebutuhan sistem seperti protokol jaringan, FFI, VM, dan infrastruktur tingkat rendah.
Pendeklarasian struct di RustS+ dilakukan dengan satu field per baris, di mana nama field diikuti langsung oleh tipe datanya. Dengan pendekatan ini, definisi struktur data menjadi lebih mudah dibaca dan menyerupai deklarasi data di bahasa tingkat tinggi seperti Python, namun tetap menjaga eksplisitnya tipe seperti di Rust. Semua atribut Rust seperti #[repr(C)] atau atribut lain tetap dapat digunakan apa adanya, karena RustS+ adalah superset yang tidak membatasi fitur sistem Rust.
Instansiasi struct di RustS+ dirancang agar terasa alami dan intuitif. Pengguna cukup menuliskan nama struct, diikuti blok {} berisi pasangan field dan nilai menggunakan tanda =. Berbeda dari Rust yang menggunakan tanda titik dua, RustS+ menggunakan tanda sama dengan untuk menegaskan bahwa proses ini adalah assignment nilai, bukan deklarasi tipe. Literal string secara otomatis diturunkan menjadi String::from, sehingga kepemilikan data tetap jelas dan aman. Ownership pada struct tetap mengikuti aturan Rust sepenuhnya; ketika sebuah struct dipindahkan, maka semua field di dalamnya ikut berpindah kepemilikan tanpa pengecualian.
Akses field pada struct di RustS+ tetap menggunakan notasi titik seperti di Rust, tanpa perubahan semantik. Mutasi terhadap field struct tunduk pada aturan mutability dan scope RustS+ yang telah ditetapkan sebelumnya. Jika mutasi dilakukan di scope lokal, maka ia bersifat lokal. Jika mutasi dimaksudkan untuk memengaruhi struct di scope luar, maka mekanisme eksplisit seperti outer harus digunakan, sehingga tidak ada perubahan data yang terjadi secara tersembunyi. Dengan demikian, RustS+ menjaga prinsip bahasa sistem: semua efek samping harus terlihat jelas di kode.

Konsep Enum dalam RustS+
Enum dalam RustS+ berfungsi sebagai representasi tipe diskrit yang aman dan ekspresif untuk memodelkan state, pesan, dan event dalam sistem. RustS+ mempertahankan kekuatan enum Rust sepenuhnya, termasuk jaminan exhaustive checking dan keamanan pattern matching, tetapi menyederhanakan cara penulisannya agar lebih natural dan mudah dibaca. Setiap varian enum ditulis pada baris terpisah tanpa koma, dengan tiga kemungkinan bentuk: varian kosong tanpa payload, varian dengan payload tuple, dan varian dengan payload berbentuk struct.
Varian enum tanpa payload merepresentasikan keadaan sederhana, sedangkan varian dengan payload tuple digunakan untuk membawa satu atau beberapa nilai. Untuk payload yang kompleks dan terstruktur, RustS+ mengizinkan varian enum berbentuk struct, yang didefinisikan dengan sintaks mirip struct di dalam enum. Pendekatan ini memungkinkan model data yang kaya tanpa harus membuat banyak tipe terpisah, sekaligus menjaga layout dan tipe tetap eksplisit.
Pembuatan nilai enum di RustS+ dilakukan dengan sintaks yang konsisten dan mudah dikenali. Varian enum diakses menggunakan EnumName::Variant, dan jika varian tersebut memiliki payload, nilai payload diberikan langsung di dalam tanda kurung atau blok struktur. Tidak ada sintaks tambahan atau magic runtime yang disisipkan; semua ekspresi enum langsung diturunkan ke Rust murni.
Untuk mengakses data di dalam enum, RustS+ mempertahankan mekanisme match seperti di Rust. Pattern matching tidak disederhanakan secara berlebihan, karena di sinilah kekuatan sistem Rust berada. Dengan mempertahankan match, RustS+ memastikan bahwa pemeriksaan kelengkapan varian tetap dilakukan oleh compiler Rust, sehingga tidak ada kemungkinan state yang terlewat secara diam-diam. Ini sangat penting untuk sistem seperti state machine, consensus protocol, dan message passing, di mana setiap kemungkinan state harus ditangani secara eksplisit.
Filosofi Pemakaian Struct & Enum di RustS+
Penggunaan struct dan enum dalam RustS+ mencerminkan filosofi utama bahasa ini: sederhana di permukaan, kuat di fondasi. RustS+ tidak mencoba menjadi bahasa dinamis atau menyembunyikan kompleksitas sistem, tetapi berusaha membuat kompleksitas tersebut dapat ditulis dan dipahami dengan lebih mudah. Dengan menggabungkan kesederhanaan visual ala Python dan ketegasan semantik ala Rust, RustS+ memungkinkan pengembang membangun sistem besar dengan kode yang bersih, mudah diaudit, dan tetap aman secara memori.
Dalam praktiknya, struct digunakan untuk memodelkan data konkret dan layout memori, sementara enum digunakan untuk memodelkan variasi keadaan dan alur logika sistem. Keduanya bekerja bersama untuk membentuk fondasi bahasa sistem yang kokoh, di mana setiap byte, setiap kepemilikan, dan setiap cabang logika dapat ditelusuri dengan jelas. Dengan konsep ini, RustS+ siap menjadi bahasa yang tidak hanya nyaman digunakan, tetapi juga layak dipercaya untuk membangun infrastruktur kritis.