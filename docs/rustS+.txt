**RustS+ Variable System**

RustS+ adalah bahasa superset di atas Rust yang bertujuan membuat penulisan kode menjadi sederhana seperti Python, tetapi tetap mempertahankan kekuatan, keamanan memori, dan determinisme milik Rust. Oleh karena itu, sistem variabel RustS+ dirancang bukan untuk menggantikan sistem Rust, tetapi untuk menjadi lapisan sintaks dan inferensi di atasnya. Semua kode RustS+ harus selalu dapat diturunkan menjadi kode Rust yang valid dan aman, dan Rust tetap menjadi otoritas final melalui borrow checker, type checker, dan LLVM backend.
Dalam RustS+, kata kunci let tidak wajib. Setiap assignment dalam bentuk nama = ekspresi dianggap sebagai deklarasi variabel baru, kecuali jika variabel tersebut sudah pernah dideklarasikan sebelumnya dalam scope yang sama. Ketika pengguna menulis a = 10, sistem akan memperlakukan ini sebagai deklarasi dan mengubahnya menjadi let a = 10; pada output Rust. Jika pengguna menulis let a = 10;, maka itu dianggap sebagai Rust mentah dan dilewatkan tanpa perubahan. Dengan cara ini, RustS+ menjadi superset Rust, bukan bahasa terpisah.
RustS+ menerapkan analisis alur (flow analysis) untuk menentukan apakah suatu variabel harus bersifat mutable. Jika sebuah variabel hanya pernah diberi nilai satu kali, maka variabel tersebut akan dihasilkan sebagai let a = ... di Rust. Namun, jika variabel yang sama menerima assignment ulang di dalam scope yang sama, misalnya a = 10 diikuti oleh a = 20, maka RustS+ akan mengeluarkan deklarasi awal sebagai let mut a = 10; dan assignment berikutnya sebagai a = 20;. Dengan demikian, mutability tetap eksplisit di level Rust, tetapi otomatis di level RustS+.
Sistem tipe pada RustS+ bersifat opsional. Jika pengguna menulis a: i32 = 10, maka tipe tersebut akan diteruskan secara eksplisit ke Rust menjadi let a: i32 = 10;. Namun, jika pengguna menulis a = 10, maka RustS+ tidak menebak tipe secara mandiri, melainkan membiarkan Rust melakukan type inference. RustS+ hanya bertugas menjaga agar sintaks tetap konsisten dan aman, bukan menggantikan sistem tipe Rust.
Literal string dalam RustS+ memiliki aturan khusus untuk memastikan ergonomi tanpa mengorbankan keamanan memori. Ketika pengguna menulis a = "hello", RustS+ secara default menganggap ini sebagai objek String, bukan &'static str, dan akan mengubahnya menjadi let a: String = String::from("hello");. Hal ini membuat string tersebut dapat dipinjam (&a) dan dimodifikasi sesuai aturan ownership Rust. Namun jika string tersebut digunakan dalam konteks pinjaman statis atau literal murni, Rust tetap memiliki wewenang untuk mengoptimalkan atau menolak sesuai konteks.
Sistem borrowing di RustS+ mengikuti sintaks Rust secara langsung. Jika pengguna menulis b = &a, maka RustS+ akan menghasilkan let b = &a;. Jika pengguna menulis b = &mut a, maka hasilnya adalah let b = &mut a;. RustS+ tidak menyederhanakan atau mengabstraksi aturan borrow, karena keselamatan memori adalah inti dari Rust. RustS+ hanya membuat penulisan lebih ringkas, bukan lebih longgar.
RustS+ juga mendukung shadowing penuh seperti Rust. Jika pengguna menulis a = 10 lalu diikuti oleh a = "hello" tanpa mengubah nilai sebelumnya, maka ini dianggap sebagai deklarasi ulang, bukan mutasi. RustS+ akan mengubahnya menjadi let a = 10; lalu let a = String::from("hello");. Dengan demikian, perubahan tipe atau makna variabel selalu dilakukan melalui shadowing, bukan mutasi tipe, dan ini sepenuhnya kompatibel dengan model Rust.
Terakhir, RustS+ menjamin bahwa pengguna selalu dapat keluar dari lapisan sintaks sederhana dan menulis Rust mentah kapan pun diperlukan. Baris seperti let mut x: Vec<i32> = Vec::new(); akan dilewatkan langsung ke output Rust tanpa dimodifikasi. Ini memastikan bahwa RustS+ tidak membatasi kekuatan Rust, melainkan hanya menambahkan lapisan kenyamanan di atasnya.
Dengan desain ini, RustS+ memberikan pengalaman penulisan yang ringkas dan intuitif seperti bahasa scripting, sambil tetap menghasilkan kode Rust yang aman, eksplisit, dan berperforma tinggi. RustS+ bukan bahasa alternatif terhadap Rust, melainkan cara baru yang lebih manusiawi untuk menulis Rust.

alur sistem, parser mengubah kode rss menjadi rust, lalu compiler rust akan bekerja sampai jadi machine code

**Scope dan Block dalam RustS+**

RustS+ menggunakan sistem scope berbasis blok yang sepenuhnya konsisten dengan model Rust, tetapi dirancang agar terasa sederhana dan alami seperti Python. Setiap pasangan kurung kurawal { } membentuk sebuah scope baru. Semua variabel yang dideklarasikan di dalam { } hanya hidup di dalam blok tersebut dan akan otomatis “mati” ketika blok itu selesai. Dengan cara ini, RustS+ menjamin bahwa tidak ada variabel yang bocor keluar dari konteks tempat ia didefinisikan, sehingga kesalahan logika dan kesalahan kepemilikan data bisa dicegah sejak awal.
Ketika sebuah blok baru dimasuki, RustS+ membuat scope baru yang berada di atas scope sebelumnya. Jika sebuah variabel dengan nama yang sama dideklarasikan di dalam blok, maka itu tidak menimpa variabel luar, melainkan menciptakan variabel baru yang men-shadow variabel lama. Shadowing ini bersifat lokal: begitu blok berakhir, variabel lama langsung kembali berlaku. Ini memungkinkan penulisan kode yang bersih dan aman, misalnya menggunakan nama yang sama untuk nilai sementara tanpa merusak nilai di luar blok.
Sebagai contoh, jika pengguna menulis a = 10, lalu di dalam sebuah blok menulis a = "hello", maka di dalam blok a adalah string, tetapi di luar blok a tetap bernilai 10. RustS+ akan mengubah ini menjadi dua deklarasi let terpisah di Rust, satu di scope luar dan satu di scope dalam, sehingga tidak ada konflik tipe dan tidak ada mutasi yang tidak disengaja.
Mutasi dan Shadowing di Dalam Scope
Dalam RustS+, perubahan nilai dalam scope hanya dianggap sebagai mutasi jika variabel tersebut memang berasal dari scope yang sama. Jika sebuah variabel yang sudah ada di scope luar digunakan kembali di dalam blok tanpa perubahan tipe, maka itu adalah mutasi terhadap variabel luar dan RustS+ akan memastikan variabel tersebut bersifat mut. Namun jika tipe berubah, maka RustS+ akan menganggapnya sebagai shadowing dan membuat variabel baru di scope lokal, bukan memodifikasi yang lama. Ini menjaga konsistensi tipe dan memastikan bahwa perubahan makna variabel selalu eksplisit secara semantik.

**if dan Variabel**
Struktur if di RustS+ mengikuti aturan scope yang ketat seperti Rust. Setiap cabang if dan else adalah blok terpisah. Artinya, jika sebuah variabel dideklarasikan hanya di dalam if atau else, maka variabel itu tidak boleh digunakan di luar if. Agar sebuah variabel bisa dipakai setelah if, variabel tersebut harus sudah ada sebelum if dimulai, lalu nilainya diubah di dalam masing-masing cabang.
Contohnya, pola yang benar adalah:

result = ""
if x > 10 {
    result = "big"
} else {
    result = "small"
}
println(result)


Di sini result sudah ada sebelum if, sehingga kedua cabang hanya mengubah nilainya. Sebaliknya, jika result baru dibuat di dalam if, RustS+ akan menolak atau menghasilkan error karena variabel itu tidak memiliki satu definisi yang jelas di luar blok.
while, loop, dan Variabel Sementara
Loop di RustS+ juga membentuk scope. Variabel yang dibuat di dalam while atau loop hanya hidup selama satu iterasi dan tidak bisa digunakan setelah loop selesai, kecuali variabel itu berasal dari scope luar. Ini membuat pola seperti counter dan accumulator menjadi aman dan jelas: variabel utama seperti i atau total biasanya dibuat di luar loop, sementara variabel sementara seperti tmp dibuat di dalam loop dan otomatis dibuang setelah setiap iterasi.
Borrow dan Scope
Sistem borrowing RustS+ mengikuti aturan Rust sepenuhnya, tetapi scope membantu memastikan lifetime tetap benar. Jika sebuah referensi dibuat di dalam blok, maka referensi itu mati ketika blok selesai. Namun, selama referensi itu masih berada dalam scope yang valid dan tidak melanggar aturan borrow Rust, variabel yang dipinjam tetap aman digunakan di luar blok. Dengan cara ini, RustS+ memanfaatkan kekuatan Rust untuk menjaga keselamatan memori, sambil memberi pengguna sintaks yang lebih bersih dan intuitif.

Dalam RustS+, seluruh sistem kontrol alur seperti if, else, dan match diperlakukan sebagai ekspresi, bukan sekadar pernyataan. Artinya, setiap konstruksi kontrol alur memiliki makna nilai dan dapat digunakan langsung sebagai bagian dari ekspresi yang lebih besar, seperti assignment, return value, atau argumen fungsi. Pendekatan ini menghilangkan kebutuhan variabel sementara dan memperkecil ruang terjadinya bug logika akibat alur yang tersebar. RustS+ memilih pendekatan ini karena ia membuat logika program bersifat lokal, eksplisit, dan mudah dianalisis, sekaligus tetap mempertahankan ketegasan tipe dan determinisme ala Rust.

Sintaks else if dalam RustS+ dikunci sebagai bentuk chaining ekspresi, bukan sebagai konstruksi khusus. Secara semantik, else if diperlakukan sebagai else { if ... }, sehingga tidak ada aturan tersembunyi atau cabang istimewa dalam sistem bahasa. Dengan desain ini, RustS+ menghindari kompleksitas grammar tambahan dan memastikan bahwa seluruh percabangan memiliki makna yang seragam. Setiap cabang dalam rangkaian if / else if / else wajib menghasilkan nilai dengan tipe yang konsisten, kecuali jika seluruh ekspresi secara eksplisit dimaksudkan untuk menghasilkan (). Dengan demikian, tidak ada jalur eksekusi yang “diam-diam” tidak menghasilkan nilai, yang sering menjadi sumber bug logika.

Sistem match dalam RustS+ dikunci sebagai mekanisme ekspresi utama untuk pattern matching, dan tidak diposisikan sebagai statement imperatif. RustS+ secara sengaja mempertahankan kekuatan semantik match Rust, termasuk pemeriksaan kelengkapan (exhaustiveness) dan ketepatan pola, tetapi menyederhanakan sintaksnya agar lebih bersih dan Python-like. Simbol-simbol yang dianggap berisik seperti koma dan panah (=>) dihilangkan, digantikan oleh blok ekspresi yang langsung mengikuti pola. Dengan cara ini, setiap pola dibaca sebagai “jika cocok, evaluasi blok ini dan hasilkan nilainya”, tanpa simbol tambahan yang mengganggu pembacaan logika.

Dalam RustS+, setiap cabang match wajib menghasilkan sebuah nilai, kecuali jika seluruh match tersebut dimaksudkan sebagai ekspresi (). Tidak ada fallthrough implisit, tidak ada cabang kosong, dan tidak ada konversi tipe tersembunyi antar cabang. Jika satu cabang menghasilkan nilai dengan tipe yang berbeda, maka kesalahan tersebut harus terdeteksi pada tahap kompilasi awal RustS+, sebelum kode diturunkan ke Rust. Dengan demikian, match tidak hanya menjadi alat pemilihan cabang, tetapi juga alat penegasan makna dan konsistensi logika.

Pola match dalam RustS+ tetap mendukung seluruh kekuatan Rust, termasuk destructuring tuple, struct, enum variant, guard (if condition), dan wildcard. Namun, cara penulisannya disederhanakan agar lebih menyerupai struktur logika alami, bukan aturan sintaks yang kaku. Blok yang mengikuti pola diperlakukan sebagai ekspresi murni, sehingga match dapat bersarang dengan if, match lain, atau ekspresi kompleks tanpa kehilangan keterbacaan. Dengan desain ini, RustS+ menjadikan pattern matching sebagai alat utama penulisan logika sistem, bukan fitur lanjutan yang jarang digunakan.

Dengan mengunci match dan else if sebagai ekspresi yang konsisten, RustS+ memperkuat fondasi bahasa menuju tujuan besarnya: mencegah bug logika melalui struktur yang jujur dan eksplisit. Setiap cabang logika terlihat jelas, setiap nilai yang dihasilkan dapat ditelusuri, dan tidak ada perubahan makna program yang terjadi secara implisit. Pendekatan ini menjaga keseimbangan antara kesederhanaan visual ala Python dan ketegasan semantik ala Rust, sehingga RustS+ tetap nyaman digunakan tanpa mengorbankan keandalan sebagai bahasa sistem.