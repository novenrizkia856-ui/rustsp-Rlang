Function & Parameter Semantics dalam RustS+

RustS+ adalah bahasa sistem low-level yang dirancang untuk memberikan kemudahan penulisan seperti Python tanpa mengorbankan kekuatan, determinisme, dan kontrol penuh yang dimiliki Rust. Oleh karena itu, sistem fungsi dan parameter RustS+ dibangun dengan prinsip bahwa semua aturan eksekusi, ownership, dan ABI tetap tunduk sepenuhnya pada Rust, sementara RustS+ hanya menyederhanakan sintaks dan menghilangkan kebisingan visual yang tidak esensial.

Dalam RustS+, deklarasi fungsi menggunakan kata kunci fn seperti Rust, namun dengan sintaks yang lebih ringkas. Tipe parameter ditulis tanpa tanda titik dua (:), dan tipe kembalian ditulis langsung setelah daftar parameter tanpa menggunakan panah (->). Sebagai contoh, fungsi Rust fn add(a: i32, b: i32) -> i32 dalam RustS+ ditulis sebagai fn add(a i32, b i32) i32. Untuk fungsi sederhana, RustS+ juga mendukung bentuk satu baris menggunakan tanda sama dengan (=), di mana ekspresi di sisi kanan secara otomatis menjadi nilai kembalian fungsi.

Semantik return dalam RustS+ mengikuti aturan Rust secara ketat, namun dengan ergonomi yang lebih sederhana. Jika sebuah fungsi memiliki tipe kembalian selain (), maka ekspresi terakhir dalam blok fungsi secara otomatis menjadi nilai kembalian selama tidak diakhiri dengan tanda titik koma. RustS+ secara eksplisit mencegah pemberian titik koma pada baris terakhir fungsi non-void, karena hal tersebut akan mematikan nilai kembalian dan menghasilkan perilaku yang tidak valid. Pernyataan return eksplisit tetap didukung dan diteruskan langsung ke Rust tanpa modifikasi.

Parameter fungsi dalam RustS+ wajib memiliki tipe. Hal ini adalah keputusan desain yang disengaja karena RustS+ ditujukan sebagai bahasa sistem, di mana kejelasan ABI, layout memori, dan kepemilikan data tidak boleh ambigu. Tidak ada inferensi tipe parameter, dan deklarasi fungsi dengan parameter tanpa tipe dianggap sebagai kesalahan kompilasi. Dengan demikian, setiap fungsi RustS+ selalu memiliki kontrak yang eksplisit dan dapat diprediksi.

Sistem passing parameter di RustS+ sepenuhnya eksplisit dan identik secara semantik dengan Rust. Parameter tanpa awalan (x i32, msg String) berarti passing by value dan memindahkan ownership. Parameter bertipe referensi (&T) berarti immutable borrow, sementara &mut T berarti mutable borrow. RustS+ tidak menyembunyikan aturan ownership maupun lifetime; ia hanya menyederhanakan cara penulisannya. Parameter referensi secara default bersifat immutable kecuali dinyatakan secara eksplisit sebagai &mut.

RustS+ mendukung generic pada fungsi dengan sintaks yang sederhana dan eksplisit. Generic ditulis menggunakan tanda kurung siku setelah nama fungsi, seperti fn identity[T](x T) T. Generic hanya diizinkan pada definisi fungsi dan tidak melibatkan inferensi liar atau runtime dispatch tersembunyi. Semua generic diturunkan langsung menjadi generic Rust biasa, sehingga tetap zero-cost dan aman.

Dalam tubuh fungsi, RustS+ memberlakukan sistem scope dan variabel yang sama ketatnya dengan blok biasa. Parameter fungsi diperlakukan sebagai variabel yang hidup di scope fungsi dan bersifat immutable secara default, kecuali jika bertipe &mut. Shadowing parameter di dalam blok lokal diperbolehkan dan tidak mempengaruhi nilai parameter asli, sehingga reasoning lokal tetap aman dan dapat diprediksi.

Khusus untuk operasi string, RustS+ menerapkan aturan penurunan (lowering) yang eksplisit dan deterministik agar tidak melanggar aturan ownership Rust. Jika operasi konkatenasi melibatkan referensi &String, RustS+ secara otomatis membuat salinan eksplisit menggunakan to_owned() sebelum melakukan operasi +. Dengan cara ini, biaya alokasi tidak pernah tersembunyi, dan perilaku memori tetap jelas bagi programmer. RustS+ tidak mengizinkan operasi konkatenasi pada &str murni tanpa konversi eksplisit ke String.

RustS+ juga melakukan adaptasi parameter secara terbatas dan deterministik untuk literal string. Jika sebuah fungsi mengharapkan String atau &String tetapi menerima literal string ("text"), RustS+ akan secara eksplisit menurunkannya menjadi String::from("text") atau referensinya. Adaptasi ini tidak bersifat umum dan hanya berlaku pada kasus yang aman dan dapat diprediksi; tidak ada implicit coercion yang berpotensi menyembunyikan alokasi atau perubahan ownership.

Fungsi main dalam RustS+ ditulis sama seperti Rust, tanpa perlu menyebutkan tipe kembalian. Fungsi ini menjadi titik masuk program dan seluruh aturan fungsi lainnya tetap berlaku di dalamnya. Rust mentah tetap didukung sepenuhnya di dalam file RustS+, sehingga programmer selalu dapat turun ke tingkat Rust asli jika membutuhkan kontrol maksimal.

Dengan desain ini, sistem fungsi dan parameter RustS+ menghasilkan bahasa sistem yang mudah dibaca, mudah ditulis, namun tetap keras dan jujur terhadap biaya komputasi dan memori. RustS+ tidak mencoba mengabstraksikan realitas sistem, melainkan menyajikannya dalam bentuk yang lebih manusiawi. Ini menjadikan RustS+ cocok untuk infrastruktur, distributed systems, consensus engine, dan seluruh domain yang menuntut performa, keamanan, dan prediktabilitas tingkat rendah.