changelog

add a formal system:
RustS+ going forward must not be treated as “a language with new syntax,” but as a formal system for guaranteeing the correctness of program meaning. Its development architecture starts from the premise that Rust has already solved the problem of memory correctness, while RustS+ addresses a higher-level problem: correctness of intent, state, and effects on the real world. Therefore, the entire RustS+ toolchain must be oriented toward semantic analysis, not merely textual transformation. The official RustS+ pipeline is built on a sequence of formal IRs: from .rss to AST (structure), then to HIR (meaning and scope), then to EIR (effect contracts), and only then lowered to Rust. With this architecture, RustS+ is no longer a “regex compiler,” but a semantic compiler that formally understands what a program does.

At the center of this system lies a two-layer type system: the first layer is Rust’s type system (i32, struct, enum, borrow, generics), and the second layer is the Effect Capability System. Every value has not only a data type, but also rights over reality: whether it may be read (read x), written (write x), perform I/O, allocate memory, or panic. The write(x) capability is treated as a linear resource, like &mut T in Rust: it cannot be duplicated and may only be owned by a single party at a time. This makes changes to world state exclusive, explicit, and verifiable, just like memory mutation in Rust.

Every function in RustS+ is formally typed as
(parameter types) → return type + capability set.
If a function declares effects (write acc, io), then at the type level it holds two tokens: one exclusive token to mutate acc, and one global token for I/O. When a function calls another function, these capabilities must be propagated through the type system. If a pure function attempts to call an effectful function, or if it fails to propagate effects from the callee, this becomes a type error (RSPL301 / RSPL302), not merely a warning. Under this model, “dishonest code” cannot pass, because it violates the type contract.

HIR and EIR together form a checking system equivalent to the borrow checker, but for program meaning. HIR ensures that scope, mutability, and intent (mut vs outer vs shadowing) are consistent and unambiguous. EIR constructs an Effect Graph that tracks where effects originate, how they flow, and who owns the right to perform mutations. From this graph, the compiler can detect conflicts such as two functions both writing to w without coordination, effect leakage into closures, or effects performed outside a valid scope — all before a single line of Rust code is generated.

To make this system work, RustS+ employs an Effect Inference Algorithm that runs over HIR. Each expression and statement produces an effect trace that is computed structurally, not textually. For example, literals produce no effects; reading a variable produces read(x); accessing w.x also produces read(w); while assigning to a field such as w.x = 3 produces write(w). This is because mutating a field is considered mutating the owner object. Rebinding such as w = new_w does not produce write(w) because it only changes the binding, not the object’s contents. Function calls produce the union of effects from their arguments and the capabilities declared by the function. Patterns such as println!, Vec::new, or unwrap are mapped to io, alloc, and panic at the AST level. For control flow (if, match, while), effects from all branches are merged. In this way, the compiler can compute DetectedEffects for each function and verify them against DeclaredEffects (RSPL300), enforce effect propagation between functions (RSPL301), forbid pure functions from calling effectful ones (RSPL302), and detect ownership conflicts of write(x) along execution paths (RSPL315).

With this foundation, RustS+ is ready to enter production in the same way Rust once did: through dogfooding in critical systems such as DSDN. DSDN will force RustS+ to confront the realities of concurrency, ledger state, transaction ordering, determinism, and security. Because RustS+ formalizes “who may change what and when,” it is uniquely suited to serve as a core language for financial engines, blockchain state machines, and distributed AI pipelines — domains where bugs are not mere crashes, but failures of trust.

In essence, RustS+ evolves not by adding features, but by deepening the meaning that the compiler can verify. With formal IRs, a capability-based type system, and linear effect ownership, RustS+ becomes a language that is not only memory-safe, but reality-safe. Once this foundation is solid, only then can it expand like Rust did: from DSDN to the entire world of systems that must not fail.



Hashing

Ganti DefaultHasher (u64) → SHA-256 pure Rust (FIPS 180-4)
Tambah Merkle tree hashing untuk deteksi perubahan struktur project

Incremental Compilation

Cache hasil compile di target/rustsp/*.rs (mirror struktur source)
File compile.json sebagai manifest utama (hash, path, merkle root)
Deteksi 6 jenis perubahan: new, modified, renamed, moved, deleted, unchanged
Rename/move file → skip compile (content hash match)
Tidak ada perubahan → skip compiler RustS+, langsung ke cargo

New toolchain architecture:

Struct IncrementalCompiler replaces preprocess_project()
DeployTracker replaces GeneratedFilesTracker (cached copy, not in-place)
Inline JSON parser/serializer (zero dependencies)

new commands:

--rustsp-reset / --reset clean — reset cache total
--rustsp-status — see info cache & manifest

delete:

old filecache (format .rustsp_cache tab-separated)
compile in-place system (now, compile to cache first, then deploy)

Effect detection based on TYPE SIGNATURE:
- Function has EffectSignature in TypeEnv
- Function calls to → effect lookup from signature
- ROBUST! Effect type is included, not string


-fixed all translations from rustsp to rust
-Simplification of the toolchain architecture to act as a wrapper for the original Cargo Rust
-other stabilization